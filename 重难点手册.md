# 七.高难度计算

### 1.高精度计算

![image-20221226193215953](重难点手册.assets/image-20221226193215953.png)

```c
#include <stdio.h>
#include <string.h>
int main()
{
	char a[100+3];
	char b[100+3];
	char c[100+3];
	scanf("%s %s",a,b);
	int len1 = strlen(a);
	int len2 = strlen(b);
	int len3 = len1 > len2 ? len1:len2;
	int i;
	for(i = 0 ;i < len3;i++)
	{
		c[i] = '0';
	}
	len1--; //len1表示长度，参考数组，下标从0开始
	len2--;
	for(i = len3-1;i >= 0;i--,len1--,len2--)
	{
		if(len1 >= 0)
		{
			c[i] += a[len1] - '0'; // a[len1] - '0'表示相差的ASCII码的值
		}
		if(len2 >= 0)
		{
			c[i] += b[len2]-'0';
		}
		if(c[i] > '9') //ASCII码中没有 10
		{
			if(i>0)
			{
				c[i] -= 10;
				c[i-1]++;
			}
			else
		    {
		    	printf("1"); //特殊情况，第一位进一
		    	c[i] -= 10;
			}
			
		}
	}
	for(i = 0; i< len3;i++)
	{
		printf("%c",c[i]);
	}
}
```



### 2.高精度计算的乘法

have fun with number

![image-20221228134128024](重难点手册.assets/image-20221228134128024.png)

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char s[20];
    int a[10] = {0};
    int b[10] = {0};   //对hash数组进行初始化
    scanf("%s",s);
    int len = strlen(s);
    int i,m = 0;
    int flag = 1;
    for(i = len - 1;i >= 0;i--)
    {
        int k = s[i] - '0';
        a[k]++;
        s[i] = (2 * k + m) % 10 + '0' ;    //此处为乘法的关键
        if((2 * k + m ) > 9)
        {
            m = 1;
        }
        else
        {
            m = 0;
        }
    }
    if(m == 1)
    {
        printf("No\n");
        printf("1");
        for(i = 0;i < len ;i++)
        {
            printf("%c",s[i]);
        }
    }
    else
    {
        for(i = 0; i < len;i++)
        {
            b[s[i] - '0']++;
        }
        for(i = 0; i< 10;i++)
        {
            if(a[i] != b[i])      //hash数组进行比较，比较两个数字有无变化
            {
                flag = 0;
                break;
            }
        }
        if(flag == 1)
        {
            printf("Yes\n");
        }
        else
        {
            printf("No\n");
        }
        for(i = 0;i < len ;i++)
        {
            printf("%c",s[i]);
        }
    }
}
```



```c
for(i = len - 1;i >= 0;i--)
    {
        int k = s[i] - '0';
        a[k]++;
        s[i] = (n * k + m) % 10 + '0' ;   // 乘n倍
        if((n * k + m ) > 9)
        {
            m = (n * k + m) / 10;
        }
        else
        {
            m = 0;
        }
    }
```





# 八.指针

### 8.1 取地址运算

- &作为运算符scanf("%d",&i)

- 获得变量的地址，他的**操作数必须是明确的变量**

  int i；printf("%x",&i);将i的地址以十六进制整数的形式输出

  其中 int p =int (&i);printf("%x",p);也可以

  - > **但是int p=(int)&(i++)   ——error**

  - > **int p=(int)&(++i) —— error**

  - > **int p=(int)&（i+k） —— error**

- > **地址的大小是否与int相同取决于编译器**

  int i；printf("%p",&i);   ==%p是取地址标准运算符==

  - sizeof(int)=4;
  - sizeof(&i) = 4(字节，一字节等于8bit)   ——32位编译器
  - sizeof(&i）= 8——64位编译器

### 8.2 数组的取地址运算

```c
int a[10];
printf("%p\n",&a);         //000000000065FDF0
printf("%p\n",a);          //000000000065FDF0
printf("%p\n",&a[0]);      //000000000065FDF0
printf("%p\n",&a[1]);      //000000000065FDF4
```

- > **发现&a与a，a[0]的地址均相同，（传输数组时，只需要知道首个元素的地址和元素个数个数即可）**

- 相邻数组元素，地址相差4（int 的字节数为4）

- > **指针所指向的内存区，是从指针所代表的那个内存地址开始，长度为sizeof（）。**
  >
  > **以后我们说指针的值是多少，就相当于说指针指向了以XX为首地址的一片内存区。**
  >
  > **我们说指针指向了某块区域，就相当于说指针的值是这块内存区域的首地址**

### 8.3指针变量记录地址。

> **思考：如果能够将取得的变量的地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量呢？**

#### 8.3.1指针就是保存地址的变量

***\*以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）\****

1. 区分一下情况

   ```c
   int i;          //定义整数型的变量
   int *p=&i;      //定义指针p指向i的地址（初始化）
   int* p,q;       //定义指针p和整数型变量q
   int *p,q;       //定义指针p和整数型变量q
   ```

   特别需要注意的是：int*不是一个新的数据类型，int (空格) *p表示的才是指针

2.作为函数参数的指针

void f(int *p)  在被调用时得到的是某个变量的地址

```c
void f(int *p)
{
    printf("p=%p\n",p);
    printf("*p=%d",*p);
    *p=16;
}
int main()
{
    int i=6;
    printf("&i=%p\n",&i);
    f(&i);
    printf("i=%d",i);
}
```

结果：&i=000000000065FE1C
                     p=000000000065FE1C
                    ==*p=6==

​            i=16;

3.穿插小知识：左值

- 左值：出现在赋值号的左边，但不是变量而是值，是表达式的结果
- - a[0] = 2;    []可以看作一个运算符，相当于a#0
  - *p = 3

互相反作用

- *&abc  - ->  *****(&abc)  - - >*****(abc的地址)  - - >得到那个地址上的变量   - - > abc
- &*abc  - - > &(*****abc) - - > &(y) - - > 得到y的地址，也就是abc ——>  abc（abc首先是一个地址）



#### 8.3.2 指针的应用

（一）.swap函数

```c
void swap(int *a,int *b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}
```

（二）.函数返回多个值（某些值只能通过指针返回）

==传入的参数实际上就是需要带回的结果的变量==

1.寻找数组中的最大值和最小值（一次满足）

```c
void findmaxmin(int a[],int len,int *max,int *min)
{
    int i;
    *max = *min = a[0];
    for(i=0;i<len;i++)
    {
        if(a[i]>*max)
        {
            *max=a[i];
        }
        if(a[i]<*min)
        {
            *min=a[i];
        }
    }
}
```

(三).函数返回运算的状态，结果通过指针返回

```c
int divide(double a,double b, double *result)
{
    int ret=1;
    if(b==0)
    {
        ret=0;
    }
    else
    {
        *result=a/b;
    }
    return ret;
}
int main()
{
    //语句
    if(divide(a,b,&result))
    {
        printf("%f/%f=%f\n",a,b,result);
    }
}
```

#### 8.3.3 指针的常见使用错误

> **定义了指针变量，但是没有指向任何变量，便开始使用**

```c
int *p;
*p = 12; //该操作是错误的，*p没有指向某一变量的地址，未进行初始化
```

概念辨析

- int p ; 这是一个普通的整型变量

- int *p;首先p是一个指针，然后p与int结合，说明指针指向的内容的类型是int，所以p是一个返回整型的指针

- int p[3];p是一个由整型组成的数组；

- > **int*p[3];**
  >
  > **首先从 p开始，先和【】结合，因为【】优先级比 *高，所以p是一个数组。**
  >
  > **然后在和*结合，说明数组中的元素都是指针类型，再与int结合，说明指针指向的内容都是整型。**
  >
  > **所以p是一个由返回整型数据的指针组成的数组**

- >**int(*p)[3];**
  >
  >**首先从p开始，先和*结合，说明p是一个指针，再与【】结合，说明指针指向的内容是一个数组，然后再与int结合，说明数组中的元素都是整型。**
  >
  >**所以p是一个由整型数据组成的数组的指针。**

- > **int (*p)(int)**
  >
  > **首先从p开始，先与*结合，说明p是一个指针，然后与（）结合，说明指针指向的是一个函数。**
  >
  > **（）里的int说明，函数有一个int型的参数，最外层的int说明函数的返回值是int。**
  >
  > **所以p是一个指向有一个整数参数且返回类型为整型的函数**







#### 8.3.4 ==指针与数组==

- 在函数调用中，sizeof(a) = 4,相当于此处的==**a是一个指针**==，==在函数中，对数组元素进行变换，相应的在main函数中数组元素发生相同的变换==

- 在main函数中，sizeof（a）= len*sizeof(a[0]),相当于此处的a是一个真实的数组

- ```c
  以下四种函数原型是等价的
  int func(int a[],int n)
  int func(int *a,int n)
  int func(int [],int )
  int func(int *,int )
  ```

- 数组变量本身表示地址

  - int a[10];int *p=a;     无需用&取地址。==a ==&a[0]==
  - 但是数组的元素表达的是变量，需要用&取地址

- []运算符可以对数组做，也可以对指针做

  - p[0]=a[0]       p[0]可以看作指针p指向的是一个数组，p[0]表示数组的第一个元素

        ```c
        min=2;
        int *p = &min;
        printf("*p=%d\n",*p);       //2
        printf("p[0]=%d\n",p[0]);   //2
        ```

  > 

  ```c
  int a[]={5,15,34,54,14,2,52,72}
  int *p = &a[5];
  printf("%d",(p+2)[0]);  //72
  则p[-2]的值为54
    p[2]的值为72
  ```

- *运算符可以对指针做，也可以对数组做   

  - *a=25,表示数组的第一个元素a[0]=25

- 数组变量是const的指针，所以不能被赋值

  - 不能b[]=a[]

  - int a[]   相当于 int *const a

例题1：

**int array[10];该语句定义了一个数组array。**

> **其中array的类型是整型指针(即：int*)    错误❌**
>
> **array 是指向 int array[0]的地址的指针**

#### 8.3.5 ==指针与const？？？？？==

> **目前有指针是const，也可以是指针指向的变量是const**

1. 指针是const，表示一旦得到某个变量的地址，不能再指向其他变量

   - int *const q=&i;    //q是const
   - *q=26        ok      (此时使i=26，变量还是i)
   - q++           error

2. 所指的是const。表示不能通过指针去修改那个变量

   - const int *p=&i;
   - *p=26     //error  (*****p)是const
   - i=26       //ok
   - p=&j       //ok

   ```c
   int i;
   const int *p1=&i;
   int const *p2=&i;       //通过指针不能修改变量
   int *const p3=&i;       //指针不可修改
   ```

   > 判断哪个被const 的标志是const在*的前面还是后面

### 8.4 指针运算

0地址，可以用0地址表示特殊的事情

- 返回的指针无效
- 指针没有被真正初始化（先初始化为0）

NULL是一个预定定义的符号，表示0地址

#### 8.4.1 给指针加减一个整数

1. 指针加一，其**表示的地址加sizeof（ ）**

2. > **给指针加一，表示要让指针指向下一个变量**

   int a[10];

   int *p = a;

   *(p+1) = a[1];

```c
char a[]={0,1,2,3,4,5,6};
char *p = a;
int b[] = {0,1,2,3,4,5,6};
int *q = b;
printf("%p\n",p);            //00````065FE09
printf("%p\n",p+1);          //00````065FE0A
printf("%p\n",q);            //000000065FDE0
printf("%p\n",q+1);          //000000065FDE4
```

#### 8.4.2 递增递减

*p++   (同为二级运算符，从右往左进行计算)

- > ***取出p所指的数据，完事后把p移到下一个位置***

- ********的优先级低于++，于是先执行p++，再***

- 一般用于数组

***++p相当于 *（p+1）**

- 取出p所指的下一个单元的数据

- 先执行（++p），再*

```c
int b[] = {1,2,3,4,5,6,0,-1};
int *p = b;
for(p=b;*p!=-1;p++)
{
    printf("%d",*p);
}
while(*p)
{
    printf("%d ",*p++);  //1 2 3 4 5 6
    printf("%d ",*++p);  //2 3 4 5 6 0
}

```



#### 8.4.3 指针相减（不能相加）

1.两指针相减，得到的数是指针地址差/sizeof（）

```c
char a[]={0,1,2,3,4,5,6};
char *p = a;
char *p1 = a[5];
int b[] = {0,1,2,3,4,5,6};
int *q = b;
int *q1 = b[6];
printf("%d\n",p1-p);       //5
printf("%d\n",q1-q);       //6
```

>**指针之间只能相减，不能相加，且只有同一类型的指针变量才能相减。指针相减的意义在于两个指针指向的内存位置之间相隔了多少个元素**

#### 8.4.4强制类型转换

```c
char a[20];
int *p=(int*)a;
p++;
```

p所指的地址由原来的变量a的地址向高地址方向增加了4字节。

原来p指向数组a的第0号元素开始的四个字节，此时指向数组a中从第4号元素开始的四个字节，

#### 8.4.5数组的动态内存分布

- int *a = (int *)malloc(n * sizeof(int ));

- **malloc函数 void * malloc(size_t,size)**

- 返回的类型是void*（表示不知道指向什么的指针）， **需要进行类型转化 从void *到 数据类型 ***
- 均要头文件 #include <stdlib.h>
- 使用malloc 函数，在程序运行时确定数组的大小

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int number;
    scanf("%d",&number);
    int *a = (int *)malloc(number*sizeof(int));//此时可以将a看作一个数组
    for(i=0;i<number;i++)
    {
        scanf("%d",&a[i]);
    }
    free(a);       //归还内存
}
```

free（）

- 申请来的空间都得还给系统

- **且只能还申请来的空间的首地址******（故在对a地址做出改变前，需要新设一个指针，指向空间的首地址）****

- **free（NULL）没有问题**

- 常见问题

  - 申请了但是没有free内存——>长时间运行内存会逐渐下降

  - free 过 再free——>程序会报错

  - 地址变过了，直接free——>报错

  - ```c
    int *p=(int*)malloc(1024*1024);
    p++;
    free(p);        //这是错误的
    ```

  - 

例题：

```c
char *p;
while(1)
{
    p = malloc(1);
    *p = 0;           
}
```

程序会一直分配内存，直至引起内存耗尽。==而malloc再分配内存失败时并不会终止程序，而是返回NULL指针==。而第五行代码试图==在NULL指针的位置写入数据，这会引起程序终止（段错误）==

##### realloc

```c
p=malloc(sizeof(int)*100);
p=realloc(p,120);
or
n=malloc(sizeof(int)*120);
for(int i=0;i<100;i++)
{
    n[i]=p[i];
}
free(p);
p=
```

# 

# 九.搜索与排序

### 9.1.1二分查找法(while 循环版)

二分查找法：按照从小到大的顺序，输入n个整数并存入数组a中，然后在数组中查找给定的x。如果数组a中的元素与x的值相同，输出相应的下标；如果没有找到，输出“not found”。如果输入的n个整数没有按照从小到大的顺序排列，或者出现了相同的数，则输出“invalid value".

> 设*n*个元素的数组*a*已升序排列，用`begin`和`end`两个变量来表示查找的区间，即在`a[begin] 〜 a[end]`区间去查找*x*。初始状态为`begin = 0，end = n-1`。首先用要查找的*x*与查找区间的中间位置元素`a[mid]`（`mid = (begin + end) / 2`）比较，如果相等则找到；如果`x < a[mid]`，由于数组是升序排列的，则只要在`a[begin] 〜 a[mid-1]`区间继续查找；如果`x > a[mid]`，则只要在`a[mid+1] 〜 a[end]`区间继续查找。也就是根据与中间元素比较的情况产生了新的区间值`begin`、`end`值，**当出现`left > right`时，说明不存在为*x*的元素。**

```c
#include <stdio.h>

# define MAXN 10
int main()
{
    int n,x;
    scanf("%d %d",&n,&x);
    int a[MAXN];
    int i;
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    int sorted=1;
    for(i=0;i<n-1;i++)
    {
        if(a[i]>=a[i+1])
        {
            sorted=0;
            break;
        }
    }
    if(sorted==0)
    {
        printf("invalid value");
    }
    else
    {
        int found=0;
        int begin=0,end=n-1;
        int mid;
        while(begin<=end)
        {
            mid=(begin+end)/2;
            if(a[mid]==x)
            {
                found=1;
                break;
            }
            else if(a[mid]>x)
            {
                end=mid-1;
            }
            else
            {
                begin=mid+1;
            }
        }
        if(found==1)
        {
            printf("%d",mid);
        }
        else{
            printf("not found");
        }
    }
}
```

### 9.1.2 二分搜索法（递归法）

```c
#include <stdio.h>
int search(int x, int a[], int begin , int end)
{
    int ret=-1;
    int mid = (begin + end)/2;
    if(begin > end)
    {
        ret=-1;
    }
    if(a[mid]==x)
    {
        ret = mid;
    }
    else if(a[mid]>x)
    {
       ret = search(x,a,begin,mid-1);
    }
    else{
        ret = search(x,a,mid+1,end);
    }
    return ret;
}
int main()
{
    int n,x;
    scanf("%d %d",&n,&x);
    int a[n];
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    int begin = 0;
    int end = n-1;
    int index = search(x,a,begin,end);
    if(index==-1)
    {
        printf("not found");
    }
    else{
        printf("%d",index);
    }
}
```

### 9.2.1 选择法排序（for循环版）

本题要求将n个整数从小到大排序后输出。输出时相邻的数字间一个空格，行末没有多余的空格

> **此处展示的是将最小数置于第一位（依次后移）**
>
> **第0步：在未排序的*n*个数（*a*[0]〜 *a*[*n*−1]）中找到最小数，将它与 *a*[0]交换；**
>
> **第1步：在剩下未排序的*n*−1个数（*a*[1] 〜 *a*[*n*−1]）中找到最小数，将它与 *a*[1] 交换；**
>
> **……**
>
> **第*k*步：在剩下未排序的*n*−*k*个数（*a*[*k*]〜*a*[*n*−1]）中找到最小数，将它与 *a*[*k*] 交换；**
>
> **……**
>
> **第*n*−2步：在剩下未排序的2个数（*a*[*n*−2] 〜*a*[*n*−1]）中找到最小数，将它与 *a*[*n*−2]交换。**

```c
#include <stdio.h>
# define MAXN 10
int main()
{
    int n;
    scanf("%d",&n);
    int a[MAXN];
    int i,j,temp;
    for(i = 0;i < n;i++)
    {
        scanf("%d",&a[i]);
    }
    if(n==1)
    {
        printf("%d",a[0]);
    }
    else
    {
        int index;
        for(i = 0;i<n-1;i++)
        {
            for(j = i+1;j<n;j++)
            {
                if(a[j]<a[i])
                {
                    int temp = a[j];
                    a[j] = a[i];
                    a[i] = temp;
                }
            }
        }
        for(i = 0;i < n;i++)
        {
            if(i==0)
            {
                printf("%d",a[i]);
            }
            else{
                printf(" %d",a[i]);
            }
        }
    }
    
}
```

### 9.2.2 选择法排序（递归版）

此处为将最大数移到最后一位（依次前移）

```c
#include<stdio.h>
int findmax(int a[],int begin,int end)
{
    int index = begin;
    int i;
    for(i = begin;i <=end;i++)
    {
        if(a[i]>a[index])
        {
            index=i;
        }
    }
    return index;
}
void sort(int a[],int begin,int end)
{
    int temp,index;
    if(begin<=end)
    {
        index = findmax(a,begin,end);
        temp=a[index];
        a[index]=a[end];
        a[end]=temp;
        sort(a,begin,end-1);
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    int a[10],i;
    for(i=0;i < n;i++)
    {
        scanf("%d",&a[i]);
    }
    sort(a,0,n-1);
    for(i=0;i<n;i++)
    {
        printf("%d ",a[i]);
    }
}
```

#### 9.2.3尾递归转化为while和for循环

```c
void sort(int a[],int begin,int end)
{
    int temp,index;
    while(begin<=end)
    {
        index = findmax(a,begin,end);
        temp=a[index];
        a[index]=a[end];
        a[end]=temp;
        end--;
    }
}

```

### 9.3.1冒泡排序

> **冒泡排序的算法步骤描述如下：**
>
> **第1步：在未排序的*n*个数（*a*[0]〜 *a*[*n*−1]）中，从*a*[0]起，依次比较相邻的两个数，若邻接元素不符合次序要求，则对它们进行交换。本次操作后，数组中的最大元素“冒泡”到*a*[*n*−1]；**
>
> **第2步：在剩下未排序的*n*−1个数（*a*[0] 〜 *a*[*n*−2]）中，从*a*[0]起，依次比较相邻的两个数，若邻接元素不符合次序要求，则对它们进行交换。本次操作后，*a*[0] 〜 *a*[*n*−2]中的最大元素“冒泡”到*a*[*n*−2]；**
>
> **……**
>
> **第*i*步：在剩下未排序的*n*−*k*个数（*a*[0]〜*a*[*n*−*i*]）中，从*a*[0]起，依次比较相邻的两个数，若邻接元素不符合次序要求，则对它们进行交换。本次操作后，*a*[0] 〜 *a*[*n*−*i*]中的最大元素“冒泡”到*a*[*n*−*i*]；**
>
> **……**
>
> **第*n*−1步：在剩下未排序的2个数（*a*[0] 〜*a*[1]）中，比较这两个数，若不符合次序要求，则对它们进行交换。本次操作后，*a*[0] 〜 *a*[1]中的最大元素“冒泡”到*a*[1]。**

```c
#include <stdio.h>
# define MAXN 10
int main()
{
    int i,j,n,temp;
    int a[MAXN];
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    for(i=1;i<n;i++)
    {
        for(j=0;j<n-1;j++)      //或者j<n-i;每一轮都将此时的最大时放到末尾
        {
            if(a[j]>a[j+1])
            {
                temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
            }
        }
    }
    for(i = 0;i < n;i++)
    {
        if(i==0)
        {
            printf("%d",a[i]);
        }
        else{
            printf(" %d",a[i]);
        }
    }
}
```

#### 9.3.2尾递归函数

```c
void bubble_sort(int a[],int size)
{
    for(int i=1;i<size;i++)
    {
        for(int j=0;j<size-i;j++)
        {
            if(a[j]>a[j+1])
            {
                int temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
            }
        }
    }
}
```

#### 9.3.3 冒泡排序的优化

冒泡过程中，有可能顺便把多个数据一起排好了顺序

如果发现提前排好了，下一轮就可以少跑几个数据

```c
void bubble_sortplus(int a[],n)
{
    int i,j,temp,loc=-1;
    for(i=1;i<n;i++)
    {
        loc=-1;
        for(j=0;j<n-i;j++)
        {
            if(a[j]>a[j+1])
            {
                temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
                loc=j;
            }
        }
        i=n-loc-1;
    }
}
```

### 9.4.1插入排序（for循环版）

思路：先将前n-1个数顺序排好，在插入最后一个数

编程实现插入排序函数。

**void insertionSort(int [], int n);**。其中a存放待排序的数据，n为数组长度（1≤n≤1000）。

```c
#include <stdio,h>
#define MAXN 1000
int main()
{
    int n,i,j;
    scanf("%d",&n);
    int a[MAXN];
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    insertionsort(a,n);
    printarray(a,n);
}
void insertionsort(int a[],int n)
{
    int i,j,temp;
    for(i=0;i<n;i++)
    {
        for(j=0;j<i;j++)             //此处区别于冒泡排序（先排前i个）
        {
            if(a[i]<a[j])
            {
                temp=a[i];
                a[i]=a[j];
                a[j]=temp;
            }
        }
    }
}
void printarray(int a[],int n)
{
    for(int i=0;i<n;i++)                       
    {                                                
        if(i==0)
        {
            printf("%d",a[i]);
        }
        else
        {
            printf(" %d",a[i]);
        }
    }
}
//或者可以写作
void printarray(int a[],int n)
{
    for(int i=0;i<n;i++)
    {
        printf("%d",a[i]);
    }
    if(i<n-1)
    {
        printf(" ");
    }
}
```

#### 9.4.2插入排序（递归版）

```c
void insertionsort(int a[],int n)
{
    if(n>0)
    {
        insertionsort(a,n-1);
        int i,j,x;
        x=a[n-1];
        for(i=n-2;i>=0;i--)
        {
            if(a[i]>x)
            {
                a[i+1]=a[i];
            }
            else
            {
                break;
            }
        }
        a[i+1]=x;
    }
}

if(n>0)
	{
		int i,temp;
		insertsort(a,n-1);
		for(i = n-1;i>= 0;i--)
		{
			if(a[i+1]<a[i])
			{
				temp = a[i];
				a[i] = a[i+1];
				a[i+1] = temp;
			}
		}
	}
```





### ==9.5 C语言内置的排序的函数==

> **void qsort(void* base,size_t num,size_t width,int(__cdecl*compare)(const void*,const void*));**

```c
#include <stdlib.h>

int cmp_int(const void*_a,const void*_b)
{
    int* a = (int*)_a;  //从void*zhuan'hau
    int* b = (int*)_b;
    return *a - *b;
}
int cmp_double(const void*_a.const void*_b)
{
    double* a = (double*)_a;
    double* b = (double*)_b;
    return *a - *b;
}

int cmp_char(const void* _a , const void* _b)　
{
    char* a = (char*)_a;    
    char* b = (char*)_b;
    return *a - *b;　　
}


int main()
{
    //构造数组()
    qsort(arr,n,sizeof(数据类型),cmp);
}
```

### ==9.6 快速排序==

快速排序所采用的思想是分治的思想。所谓分治，就是指以一个数为基准，将序列中的其他数往它两边“扔”。以从小到大排序为例，比它小的都“扔”到它的左边，比它大的都“扔”到它的右边，然后左右两边再分别重复这个操作，不停地分，直至分到每一个分区的基准数的左边或者右边都只剩一个数为止。这时排序也就完成了。

假设序列中有 n 个数，将这 n 个数放到数组 A 中。“舞动算法”中一趟快速排序的算法是：

1. 设置两个变量 i、j，排序开始的时候：i=0，j=n–1。
2. 以数组第一个元素为关键数据，赋给变量 key，即 key=A[0]。
3. 从 j 开始向前搜索，即由后开始向前搜索（j--），找到第一个小于 key 的值 A[j]，将 A[j] 和 A[i] 互换。
4. 然后再从 i 开始向后搜索，即由前开始向后搜索（++i），找到第一个大于 key 的 A[i]，将 A[i] 和 A[j] 互换。
5. 重复第 3、4 步，直到 i=j。此时就能确保序列中所有元素都与 key 比较过了，且 key 的左边全部是比 key 小的，key 的右边全部是比 key 大的。

下面列举一个简单的例子，比如对如下数组 a 中的元素使用快速排序实现从小到大排序：

>  35 12 37 -58 54 76 22

1) 首先**分别定义 low 和 high 用于存储数组第一个元素的下标和最后一个元素的下标**，即 **low=0，high=6**。

2) 然后定义 key 用于存放基准数，理论上该基准数可以取序列中的任何一个数。此处就取数组的第一个元素，即把 a[low] 赋给 key。

3) 然后 key 和 a[high] 比较，即 35 和 22 比较，35>22，则它们互换位置：

> 22 12 37 -58 54 76 35

4) 然后 low++==1，key 和 a[low] 比较，即 35 和 12 比较，12<35，则不用互换位置；继续 low++==2，然后 key 和 a[low] 比较，即 35 和 37 比较，37>35，则它们互换位置：

> 22 12 35 -58 54 76 37

5) 然后 high--==5，key 和 a[high] 比较，即 35 和 76 比较，35<76，则不用互换位置；继续 high--==4，然后 key 和 a[high] 比较，即 35 和 54 比较，35<54，则不用互换位置；继续 high--==3，然后 key 和 a[high] 比较，即 35 和 -58 比较，35>–58，则它们互换位置：

> 22 12 -58 35 54 76 37

6) 然后 low++==3，此时 low==high，第一轮比较结束。从最后得到的序列可以看出，35 左边的都比 35 小，35 右边的都比 35 大。这样就以 35 为中心，把原序列分成了左右两个部分。接下来只需要分别对左右两个部分分别重复上述操作就行了。

***其中每一轮都是key与a[low]或者a[high]交换***

#### 9.6.1交换版

```c
#include <stdio.h>
void swap(int*a,int*b)
{
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
}
void quicksort(int a[],int low,int high)
{
    int i = low;
    int j = high;
    int key = a[i];
    if(i >= j)
    {
        return;
    }
    while(i < j)
    {
        while(i < j && a[j]>=key)  
        {
            j--;
        }
        if(a[j] < key)
        {
            swap(&a[i],&a[j]);
        }
        while(i < j && a[i] <= key )
        {
            i++;
        }
        if(a[i] > key)
        {
            swap(&a[i],&a[j]);
        }
    }
    quicksort(a,low,i-1);
    quicksort(a,i+1,high);
}
int main()
{
    int n;
    scanf("%d",&n);
    int i,a[n];
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    quicksort(a,0,n-1);
    for(i=0;i<n;i++)
    {
        printf("%d ",a[i]);
    }
}
```

> **注意点：**
>
> 1. **不要判断if（i >= j) return; 否则程序会一直持续下去**
>
> 2. **先对j进行操作，第一个小于key的值移到第一位。否则，先对i操作的话，会自然地跳过key，从而无法实现分割。**

#### 9.6.2直接赋值版

```c
# include <stdio.h>
void QuickSort(int a[], int low, int high);  /*现在只需要定义一个函数, 不用交换还省了一个函数, 减少了代码量*/
int main(void)
{
    int i;  //循环变量
    int a[] = {900, 2, -58, 3, 34, 5, 76, 7, 32, 4, 43, 9, 1, 56, 8,-70, 635, -234, 532, 543, 2500};
    QuickSort(a, 0, 20);  /*引用起来很简单, 0为第一个元素的下标, 20为最后一个元素的下标*/
    printf("最终排序结果为:\n");
    for (i=0; i<21; ++i)
    {
        printf("%d ", a[i]);
    }
    printf("\n");
    return 0;
}
void QuickSort(int *a, int low, int high)
{
    int i = low;
    int j = high;
    int key = a[low];
    if (low >= high)  //如果low >= high说明排序结束了
    {
        return ;
    }
    while (low < high)  //该while循环结束一次表示比较了一轮
    {
        while (low < high && a[high] >= key)
        {
            --high;  //向前寻找
        }            //找到第一个比key小的数
        if (key > a[high])
        {
            a[low] = a[high];  //直接赋值（a[low]初始值就是key）, 不用交换
            low++;
        }
        while (low < high && key >= a[low])
        {
            ++low;  //向后寻找
        }
        if (key < a[low])
        {
            a[high] = a[low];  //直接赋值, 不用交换
            --high;
        }
    }
    a[low] = key;  //查找完一轮后key值归位, 不用比较一次就互换一次。此时key值将序列分成左右两部分
    QuickSort(a, i, low-1);  //用同样的方式对分出来的左边的部分进行同上的做法
    QuickSort(a, low+1, j);  //用同样的方式对分出来的右边的部分进行同上的做法
}
```

#### 9.6.3双指针嵌套使用(取中间数为基准值)

```c
int partition(int a[],int low,int high)
{
    int i = low-1;               //do while 循环中先进行i++；a[i]从a[0]开始
    int j= high+1;               //同理，a[j]从a[n-1]开始
    int mid = (low+high)/2;
    int key=a[mid];
    while(low < high)
    {
        do
        {
            j--;
        }
        while(a[j]>key);
        do
        {
            i++;
        }
        while(a[i]<key);
        if(i>=j) return j;//j的反列是a[j]<=key,故会在等于的时候停住，也就是key的位置
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
void quicksort(int a[],int low, int high)
{
    if(low>=high)
    {
        return;
    }
    int pivot=partition(a,low,high);
    quicksort(a,0,pivot);
    quicksort(a,pivot+1,high);
}
```

#### 9.6.4双函数嵌套（取第一位为基准值）

```c
fu'zhi
int partition(int a[],int low,int high)
{
    int i=low;
    int j=high;
    int key=a[i];
    while(i<j)
    {
    	while(a[j]>=key&&j>i)
    	{
    		j--;
		}
		a[i]=a[j];
		while(a[i]<=key&&j>i)
		{
			i++;
		}
		a[j]=a[i];
	}
	a[i]=key;
	return i;
}
void quicksort(int a[],int low, int high)
{
    if(low>=high)
    {
        return;
    }
    int pivot=partition(a,low,high);
    quicksort(a,0,pivot-1);
    quicksort(a,pivot+1,high);
}
交换法
nt partition(int a[],int low,int high)
{
	int i =low;
	int j = high;
	int key = a[low];
	while(i<j)
	{
		while(i<j && a[j] >= key)
		{
			j--;
		}
		if(a[j] < key)
		{
			int t =a[i];
			a[i] = a[j];
			a[j] = t;
		}
		while(i < j &&a[i] <= key)
		{
			i++;
		}
		if(a[i] > key)
		{
			int t =a[i];
			a[i] = a[j];
			a[j] = t;
		}
		if(i >= j)
		{
			return i;
		}
	}
}
```

#### 9.6.5单指针嵌套（去最后一位为基准值）

```c
#include <stdio.h>
void swap(int*a,int*b)
{
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
}
int partition(int a[],int low,int high)
{
    int key=a[high];
    int i=low;
    int j;
    for(j=low;j<=high;j++)
    {
    	if(a[j]<key)                  //特殊情况第一位就小于key，ij分别变成low+1；
    	{
    		swap(&a[i],&a[j]);
    		i=i+1;
		}
		
	}
	swap(&a[i],&a[high]);         //只有a[j]<key时才会与a[i]交换，并且j必然大于i，从而i所在的位置是一个大于等于key的数，最后a[i]要与a[high](也就是key)交换
	return i;   //此时i的位置就是key
}
void quicksort(int a[],int low,int high)
{
	if(low>=high)
    {
        return;
    }
    int pivot=partition(a,low,high);
    quicksort(a,low,pivot-1);
    quicksort(a,pivot+1,high);
}
int main()
{
    int n;
    scanf("%d",&n);
    int i,a[n];
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    quicksort(a,0,n-1);
    for(i=0;i<n;i++)
    {
        printf("%d ",a[i]);
    }
}
```









### ==9.7 归并排序（mergesort）==

![](C:/Users/86198/Desktop/一.基础知识.assets/merge sort.png)

```c
#include <stdio.h>

void mergesort(int a[],int low, int high);
void merge(int a[],int low,int mid,int high);

int main()
{
    int n;
    scanf("%d",&n);
    int a[n];
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    mergesort(a,0,n-1);
    for(int i=0;i<n;i++)
    {
        printf("%d ",a[i]);
    }   
}
void mergesort(int a[],int low,int high)
{
    if(high-low<1)        //相当于low>=high
    {
        return;
    }
    int mid=(low+high)/2;
    mergesort(a,low,mid);
    mergesort(a,mid+1,high);
    merge(a,low,mid,high);     //先将左右两边按顺序排好，再用
}
void merge(int a[],int low,int mid,int high)
{
    int i=low;
    int j=mid+1;
    int b[high+1];
    for(int k=low;k<=high;k++)
    {
        if(i<=mid&&(a[i]<a[j]||j>high))
        {
            b[k]=a[i++];
        }
        else
        {
            b[k]=a[j++];
        }
    }
    for(int k=low;k<=high;k++)
    {
        a[k]=b[k];
    }
}

void merge(int a[],int low,int mid,int high)
{
	int i =low;
	int j = mid+1;
	int b[high+1];
	int k;
	for( k = low;k <= high && i<=mid &&j<=high;k++)
	{
		if(a[i] < a[j])
		{
			b[k] = a[i];
			i++;
		}
		else
		{
			b[k] = a[j];
			j++;
		}
	}
	for(;i<= mid;i++)
	{
		b[k++] = a[i];
	}
	for(;j <= high;j++)
	{
		b[k++] = a[j];
	}
	for(i=low;i<=high;i++)
	{
		a[i] = b[i];
	}
}
```

- - 





# 十.字符串(没有字符串类型)

```c
char word[]={'h','e','l','l','o','\0'};
```

- 首先字符串需要以'\0'结尾

  - 但是0或'\0'是一样的，但是"0"和前者不同

  - > 0标志着字符串的结束，**但不是字符串的一部分**

  - ***计算字符串长度的时候不包含这个0***

  - ***但是计算数组的长度时包含'\0'(是单引号的0，不是双引号)***

### 10.1 字符串变量

#### 10.1.1字符串常量

```c
char *str = "hello";   //字符指针，指向字符串自变量
char word[] = "hello"; //字符数组
char line[10] = "hello";
```

- > "hello"会被编译器变成一个字符数组放在某处，💢💢💢💢**这个数组的长度为6，结尾还有表示结束的"\0"**⛔
  >
  > printf("%d\n",strlen(word));    5
  > printf("%d\n",sizeof(word));    6

- 两个相邻的字符串常量会被自动连接起来

- c语言的字符串以**字符数组**的形式存在

  - 可以通过数组的方式可以遍历字符串

  - ```c
    #include <stdio.h>
    int main()
    {
    	char word[]="hello";
        for(int i=0;word[i] != '\0';i++)
        {
            printf("%c ",word[i]); //h e l l o
        }
    }
    
    ```

  - 


---



> ## char *s = "hello"

- **s是一个指向字符的指针，当指向的字符数组的结尾是'\0'时，才指向字符串****(**字符串的限制条件)****

  - 但是这个字符串常量所在的地方是**只读区（RO，read only）**，实际上是**const char *s(不能通过指针去修改变量的值)**

  - ```c
    char *s="hello";
    s[0]="B";             //此处便会发生段错误
    printf("%c",s[0]);
    ```

- 如果需要修改字符串常量，则需要使用数组

  - char word[] = "hello"

  - ```c
    word[1]='o';
    	printf("%s\n",word);    //hollo
    ```

  - 

> **总结：如果要构造一个字符串——数组**
>
> ​            **如果要处理一个字符串——指针**

空字符串

- char string[100]="";
  - 这是一个空的字符串，string[0]=='\0';
- char string[]="";
  - 这个数组的长度为1，只有string[0]=='\0';

并且''不合法

### 10.2字符串输入输出

```c
char string[8];
scanf("%s",string);
printf("%s",string);
```

scanf读入一个单词（到空格、tab或者回车为止）

但是scanf存在着不足，无法知道读入字符串的长度,容易造成系统错误

>  **解决方法：a安全输入**
>
>  ```c
>  char string[8];
>  scanf("%7s",string);
>  ```
>
>  **在百分号与s之间的数字表示最多允许读入的字符的数量，这个数字应比数组的大小小1（结尾的'\0'）**
>
>  ```c
>  char string[5];
>  scanf("%4s",string);      //123456789
>  printf("%s\n",string);    //1234
>  scanf("%4s",string);
>  printf("%s\n",string);    //5678
>  ```
>
>  

常见错误：

```c
char *string;
scanf("%s",string);
```

以为char*是字符串类型，但实际上是指针

没有对指针进行初始化，例如：char *string = &p;

### 10.3字符组数组

首先char[ ] [ ]与char *a不同

![](C:/Users/86198/Desktop/一.基础知识.assets/指针.png)

```c
#include <stdio.h>
int main()
{
    char *m[]={"Jan","Feb","Mar","Apr","May","June","July","Aug","Sep","Oct","Nov","Dec"};
    int month;
    scanf("%d",&month);
    printf("%s",m[month-1]);
}
```

- > 上例中，**m是一个13单元的数组，该数组的每一个单元都是指针，这些指针各指向一个字符串。**

  - 把指针数组名m看作指针的话，它指向数组的第0号元素，它指向的类型是char*
  - *m也是一个指针，它的类型是char，它指向的地址是字符"Jan"的第一个字符的地址，即“J”的地址。
  - m+1也是一个指针，它指向数组的第一号元素，指向类型char*
  - *(m+1)也是一个指针，它指向的类型是char，指向“Feb”的F

  > **粗浅的理解：指针变量可看作数组，int *p = &a[5]；此时可以直接把p看作数组，p【0】=……；p[1]=……；**
  >
  > **所以此处m表示的就是*m，它指向的类型就是char**

```c
#include <stdio.h>
int main()
{
    char m[][10]={          //表示字符串最多十个字节
    "January",
	"Februry",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December",	
    };  
    int month;
    scanf("%d",&month);
    printf("%s",m[month-1]);
}
```

<img src="C:/Users/86198/Desktop/一.基础知识.assets/image-20221202141602177.png" alt="image-20221202141602177" style="zoom:200%;" />

>**s[1] [1]表示第二个字符串的第二个字符，即d**
>
>**p是一个char*的指针，指向的是字符数组的首地址，&s[0] [0].**
>
>**++p表示指针向右移动一位即&s[0] [1],**
>
>**则 *（++p）表示s[0] [1]即’b‘，**
>
>**'b'+2,得到的就是‘d’的ASCII码**

### 10.4 字符串函数

#### 10.4.1 单字符的输入输出，用putchar 和 getchar

辨析：多字符的输入输出：

```c
char string[8];
scanf("%s",string);  //但是一次只能输7位，最后一位是'\0'
printf("%s",string);
```

1. putchar(只处理字符，不处理字符串)

- > **int putchar(int char);** **字符实际上以整数形式存储**

- 向标准输出写一个字符

- 返回写了几个字符，EOF表示写失败

```c
char ch = 'a';
putchar(ch);    //与printf("%c",ch);作用相同
putchar(ch+1);  //输出结果为b（因为以字符以整数形式存储）
```

2. getchar 

- int getchar(void);
- 从标准输入读入一个字符
- 返回类型是int 是为了返回EOF（-1)

```c
#include <stdio.h>
int main()
{
    char ch;
    while((ch = getchar())!=EOF)
    {
        putchar(ch);
    }
    printf("EOF");
}
while(1)
{
    c=getchar();
    if(c==EOF)
    {
        break;
    }
    printf("%c",c);
}
```

当输入ctrl Z时，才会输出EOF，ctrl C 强制停止

> **getchar()函数只能用于单个字符的输入，一次输入一个字符。程序的功能是输入一个字符，显示一个字符，回车换行，再输入并显示一个字符。而运行时字符是连续输入的，运行结果却是正确的，这是因为输入字符后，它们暂存于键盘的缓冲区中，然后由getchar函数从键盘缓冲区中一个一个的取出来。**



> 进入循环**前**，输入 **getchar** () 就是为了从键盘上**读取** n（输入的数字） 后输入的**空格或换行符**，使得**后面字符串的输入输出不受影响**。

##### **gets 和 puts 函数**

######  1.puts函数

puts()函数用来向标准输出设备（屏幕）写字符串并换行("\n")

```c
调用格式：
    puts(s);
```

其中s为字符串（字符串的数组名或者字符串指针）

puts（）函数的作用与printf("%s\n",s)相同

```c
char s[20],*f;
strcpy(s,"hello world");
f = "thank you";
puts(s);
puts(f);
```

补充：

1. puts()函数只能输出字符串，不能输出数值或者进行格式转换
2. 可以将字符串直接写进puts()函数中。puts("hello world");



###### 2.gets（）函数

1. gets()函数用来从标准输入设备（键盘）读取字符串直到回车结束，但回车符不属于这个字符串

2. ```c
   调用格式为：
       gets(s);
   ```

   其中s是字符串（字符串数组名或者字符串数组）

   

3. gets（）和scanf（"%s",&s）不相同

   - 使用scanf("%s",&s)时，一旦输入空格就会认为输入字符结束，空格后的字符将作为下一个输入项处理
   - gets()函数将接收输入的整个字符串直到回车为止

```c
char s[20];
char *f;
gets(s);         //输入字符串知道回车结束
puts(s)          //输出字符串并回车换行
puts("how old are you?");
gets(f);  //此处存在问题
puts(f);
```





应用举例：

```c
#include <stdio.h>
int main()
{
    char str1[20];
    char str2[5][10];
    gets(str1);
    for(int i =0;i<5;i++)
    {
        gets(str2[i]);   //注意一下此处的字符串数组
    }
    puts(str1);
    for(int i = 0;i<5;i++)
    {
        puts(str2[i]);
    }
}
```



#### 10.4.2常用函数（#include<string.h>）

##### 10.4.2.1strlen,测长度

- strlen(const char *s); const ：不会去修改输入的字符串
- **返回s的字符串长度（不包括结尾的0）**

``` c
#include <stdio.h>
#include <string.h>
int main()
{
    char line[]="hello";
    printf("strlen=%lu\n",strlen(line)); //注意用%lu unsigned long   
    printf("sizeof=%lu\n",sizeof(line)); 
}
```

strlen = 5; sizeof = 6(包括字符串结尾的'\0')

strlen函数的代码平替

```c
int mylen(const char* s)
{
    int cnt = 0;
    int idx = 0;
    while(s[idx] != '\0')
    {
        idx++;
        cnt++;
    }
    return cnt;
}
or
    while(*s!=0)
    {
        cnt++;
        p++;
    }
    return cnt;
```

##### 10.4.2.2strcmp 比较字符串的大小

- int strcmp(const char*s1,const char *s2)

- > **比较两个字符串的大小(比较的是字符串中第一个不同字符的大小)**

  - 0：s1==s2
  - 1：s1>s2
  - -1：s1<s2

```c
#include <stdio.h>
#include <string.h>
int main()
{
    char s1[] = "abc";
    char s2[] = "Abc";
    char s3[] = "abc ";
    printf("%d\n",strcmp(s1,s2)); //32
    printf("%d\n",strcmp(s1,s3)); //-32 空格的ASCLL码为32
    printf("%d\n",'a'-'A');       //32
}
```

> **不能直接if（s1==s2），此时的s1，s2都是地址，必然不相等**

```c
int mycmp(const char*s1,const char*s2)
{
    int index = 0;
    while(1)
    {
        if(s1[index] != s2[index])
        {
            break;
        }
        else if(s1[index] != '\0')
        {
            index++;
        }
    }
    return s1[index]-s2[index];
}

or
int mycmp(const char*s1,const char*s2)
{
    int index=0;
    while(s1[index]==s2[index]&&s1[index]!="\0")
    {
        index++;
    }
    return s1[index]-s2[index];
}
or
int mycmp(const char *s1,const char *s2)
{
    while(*s1 == *s2 && *s1!='\0')
    {
        s1++;
        s2++;
    }
    return *s1-*s2;
}

int mycmp(char *s1,char *s2)
{
	while(*s1 == *s2 && *s1 != '\0')
	{
		s1++;
		s2++;
	}
	if(*s1-*s2)
	{
		return 1;
	}
	else if(*s1-*s2 <0)
	{
		return -1;
	}
	else
	{
		return 0;
	}
}
```

> **此处的函数，比较也是第一个不同字符的大小的关系，只是返回值不同，此处的返回值是，字符的ASCII值之差**

##### 10.4.2.3 strcpy 函数

- char *strcpy(char *restrict dst,const char *retrict src)
  - dst表示destination 目的
  - src表示source         源
  - 目的在前，源在后
- 把src的字符串拷贝到dst
  - restrict 表明src和dst不重叠
- 返回dst，可后续使用
  - printf("%lu\n",strlen(strcpy(dst,src)));

```c
char *dst = (char*)malloc(strlen(src)+1);
strcpy(dst,src);
```

> **strlen(src)不包含字符串结尾的'\0',从而需要加1**
>
> **malloc的返回类型是void*，需要转化为char *.**

```c
char* mycpy(char *dst,const char* src)
{
    int idx = 0;
    while(src[idx] != '\0')
    {
        dst[idx]=src[idx];
        idx++;
    }
    dst[idx]='\0';  //补充结尾的0
    return dst;     //返回的是一个指针（char*）
}

char* mycpy(char *dst,const char*src)
{
    char*ret = dst;
    while(*src != '\0')
    {
        *dst = *src;
        dst++;
        src++;
    }
    *dst='\0';
    return ret;   //dst的地址发生了改变
}
```

##### 10.4.2.5 strcat函数

- char*strcat(char *restrict s1,const char *restrict s2)
- 把s2拷贝到s1的后面，接成一个长的字符串
- 返回s1
- 且s1要求具有足够的空间

```c
char* mycat(char * s1,const char* s2)
{
    int index=0;
    int len = strlen(s1);
    while(s2[index]!='\0')
    {
        s1[len+index]=s2[index];
        index++;
    }
    s1[len+index]='\0';
    return s1;
}
```



> **为了防止给出的空间不足，可以使用以下安全版本**
>
> **由n加以限制**
>
> **char* strncpy(char *restrict dst,const char *restrict src,size_t n);   将前n个进行拷贝**
>
> **char* strncat(char *restrict s1,const char *restrict s2,size_t n);   将前n个进行连接**
>
> **n=sizeof(s1)-strlen(s1)-1;**
>
> **int strncmp(const char*s1,const char *s2,size_t n);  对前n个字符进行比较**

##### 10.4.2.5 strchr函数（字符串里找字符）

- char *strchr(const char *s,int c);从左往右寻找
- char *strrchr(const char *s,int c);从右往左寻找
- 返回NULL表示没有找到

```c
#include<stdio.h>
#include <string.h>
#include <stdlib.h>
int main()
{
    char s[] = "hello";
    char*p = strchr(s,'l');
    printf("%s\n",p);       //llo
    char*t = strchr(p+1,'l');
    printf("%s\n",t);       //lo,寻找第二个字符
    char*m = (char*)malloc(strlen(p)+1);
    strcpy(m,p);
    printf("%s\n",m);       //llo,将p拷贝
    free(m);
}
```

```c
#include<stdio.h>
#include <string.h>
#include <stdlib.h>
int main()
{
    char s[] = "hello";
    char*p = strchr(s,'l');
    char c = *p;
    printf("%s\n",p);   //llo
    printf("%c\n",c);   //l
    *p='\0';
    char *t=(char*)malloc(strlen(s)+1);
    strcpy(t,s);        ////再复制的时候，遇到*p = '\0'就停止了
    printf("%s\n",t);     //he,输出目标字符前的字符串
    free(t);
    printf("%s\n",s);     //he
    *p='l';
    printf("%s\n",s);     //hello
}
```

补充：

- char *strstr(const char *s1,const char *s2)
  - 在字符串中寻找字符串
- char *strcasestr(const char *s1,const char *s2)
  - 不区分大小写寻找字符串





# 十一.结构类型

### 11.1枚举

- 枚举是一种用户定义的数据类型，它用关键字==enum==以如下语句声明：
  - enum枚举类型的名字（名字0，.....名字n）
  - enum colors{red,yelllow,green};
- 当需要一些可以排列起来的常量值时，定义枚举的意义就c是给这些常量名字。

自动计数的枚举

```c
#include <stdio.h>
enum color(red,yellow,green,numcolor);   //numcolor的大小刚好就是枚举的个数
int main()
{
    int color = -1;
    char *colornames[numcolor] = {"red","yellow","green",};
    char *colorname = NULL;
    printf("your favourite color number:");
    scanf("%d",&color);
    if(color >= 0 && color <numcolor)
    {
        colorname = colornames[color];
    }
    else
    {
        colorname = "unknown";
    }
    printf("%s",colorname);
    
}
```

- 声明枚举量的时候可以指定值
  - enum color{red=1,yellow,green=5};

### 11.2结构类型

#### 11.2.1结构类型

![image-20221202232847226](C:/Users/86198/Desktop/一.基础知识.assets/image-20221202232847226.png)

括号内的x的为整型变量，括号外的x为结构变量

```c
#include <stdio.h>
struct date
{
    int year;
    int month;
    int day;
};  //此处需要注意，要有；
int main()
{
    struct date today;  //结构变量today
    today.year = 2022;
    today.month = 07;
    today.day = 31;
    printf("today's date is %2d-%2d-%2d.\n",today.year,today.month,today.day);  //2022-7-31
}
```

1. 声明结构体的形式

```c
struct point
{
    int x;
    int y;
};
struct point p1,p2; //p1和p2 都是结构，里面有x，y的值

或者
struct point
{
    int x;
    int y;
}p1,p2;
    ``````

```c
struct   //缺少了point
{                  
    int x;
    int y;
}p1,p2;
//p1,p2都是无名结构，里面有x，y
```





```
> 定义结构后，需要再最后的{}后加上==分号==；

2. 结构成员

- 结构体变量用  .运算符  和名字访问其成员

  - eg：today.day    today.year

- 给结构体变量赋初值：

  - struct date today = {2022,7,31};

  - struct date today={2022,.day=31,.month=7}

  - 如果某一位置空缺，则自动补0；

  - > ```c
    > struct date tomorrow;
    > tomorrow = {2022,8,1};  //这是错误的
    > //正确做法：
    > tomorrow = (struct date){2022,8,1};
    > ```
    >这与数组类似，
    int a[5] = {1,2,3,4,5}; 正确做法
    int a[5];
    a[5] = {0,2,3,4,5};这是错误的

3. 结构运算

- 对于整个结构，可以做赋值、取地址，也可以传递给函数参数
- 赋值：
  - p1 = (struct point){2,4}; //相当于p1.x=2;p1.y=4;
  - p1 = p2;   //相当于p1.x = p2.x ;p1.y = p2.y;(数组不能完成该操作)

4. 结构指针

- 和数组不一样，结构变量的名字并不是结构变量的地址，必须使用&运算符
- struct date *pDate = &today;

5. 结构的sizeof

- ```c
  struct point{
      int a;
      int b;
      int c;
  }x;
  printf("%lu\n",sizeof(x));//12
  struct point{
      int a;
      char b;
      int c;
  }y;
  printf("%lu\n",sizeof(y));//12 会使整数类型出现在字节的整边界上
  struct point{
      int a;
      int b;
      char c;
  }z;
  printf("%lu\n",sizeof(z));//12
```

  ## 易错总结

> 1. **结构体成员的类型并不一定是基本数据类型**
>
> ​      **既可以是指针，也可以是数组，还可以是结构体**
>
> 2. **结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储。**

#### **11.2.2 结构与函数**

- 整个结构可以作为参数的值传入函数
- 是在函数内新建一个结构变量，并复制调用参数结构的值
- 还可以返回一个结构

##### 11.2.2.1输入结构(返回一个结构，再进行赋值)

```c
#include <stdio.h>
struct point{
    int x;
    int y;
};                  //声明函数结构
struct point getstruct(void)  //返回类型为struct point
{
    struct point m;
    scanf("%d",&m.x);
    scanf("%d",&m.y);
    printf("%d %d\n",m.x,m.y);
    return m;
}
int main()
{
    struct point p = {0,0}; //定义一个结构变量
    p = gatstruct();        //结构之间的赋值
    printf("%d %d",p.x,p.y);
}
```

##### 11.2.2.2指向结构的指针

```c
struct date {
    int year;
    int month;
    int day;
}myday;
struct date *p = &myday;
(*p).month = 12;   //先进行*p,变为结构
p->month = 12;
(*p).month++;
p->month++;
```

> **用 ->表示指针所指的结构变量中的成员**

输入结构指针版

```c
struct point* inputpoint(struct point *p)
{
    scanf("%d",&(p->x));//&(p->x)表示指针所指的结构变量的成员的地址
    scanf("%d",&(p->y));
    return p;
}
void print(const struct point *p)
{
    printf("%d %d",p->x,p->y);
}
int main()
{
    struct point m = {0,0};
    inputpoint(&m);
    printf("%d %d",m.x,m.y);
    struct point n = *inputpoint(&m);
    printf("%d %d",n.x,n.y);
    print(inputpoint(&m));
    *inputpoint(&m)=(struct point){12,98};
    printf("%d %d",m.x,m.y);    //12,98
}
```

### 11.2.3结构的结构

#### 11.2.3.1结构数组

eg：struct date dates[]={{4,5,2021},{4,5,2022}};

```c
#include <stdio.h>
struct time{
    int hour;
    int minute;
    int second;
};
struct time timeupdate(struct time now);
int main()
{
    struct time testtime[5]={{11,59,59},{12,0,0},{1,29,59},{23,59,59},{19,12,17}};
    int i;
    for(i=0;i<5;i++)
    {
        printf("time is %d:%d:%d\n",testtime[i].hour,testtime[i].minute,testtime[i].second);
        testtime[i] =  timeupdate(testtime[i]);
        printf("one second later is %d:%d:%d\n",testtime[i].hour,testtime[i].minute,testtime[i].second);
    }
}
struct time timeupdate(struct time now)
{
    ++now.second;
    if(now.second==60)
    {
        now.second=0;
        now.minute++;
        if(now.minute==60)
        {
            now.minute = 0;
            now.hour++;
            if(now.hour==24)
            {
                now.hour=0;
            }
        }
    }
    return  now;   
}
```

- 从而有结构体变量可以作为数组元素使用

#### 11.2.3.2结构中的结构

eg：

```c
struct dateandtime{
    struct date sdate;
    struct time stime;
};
```

```c
struct point{
    int x;
    int y;
};
struct rectangle {
    struct point p1;
    struct point p2;
}
int main()
{
    struct rectangle r;  //存在r.p1.x   ,     r.p1.y ,  r.p2.x  ,  r.p2.y
}
```

如果有变量定义：

struct rectangle r,*rp;  rp=&r;

那么以下四种形式等价：

- r.p1.x
- rp->p1.x
- (r.p1).x
- (rp->p1).x

> **但是没有rp->p1->x**,**因为p1不是指针**；

<img src="C:/Users/86198/Desktop/一.基础知识.assets/image-20221202231458613.png" alt="image-20221202231458613" style="zoom:200%;" />

![image-20221202232819768](C:/Users/86198/Desktop/一.基础知识.assets/image-20221202232819768.png)

### 11.3typedef

```c
typedef struct{
    int year;
    int month;
    int day;
}date;
```

意为用date去替换typedef后的代码

```c
typedef int color;
color a; //相当于int a;
```

```c
typedef struct{
    int len;
    char s[];
}string;
printf("%lu\n",sizeof(string));
string *p=(string*)malloc(sizeof(int)+20); //动态的确定的
printf("%p\n",p);
printf("%p\n",p->s);
free(p);
```

# 





# 十二.链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct _node{
    int value;
    struct _node *next;
}Node;

int main()
{
    Node *head = NULL;
    while(1)
    {
        int x;
        scanf("%d",&x);
        if(x==-1) break;
        Node *p=(Node*)malloc(sizeof(Node));
        p->value = x;
        p->next = head;
        head = p;
    }
    for(Node *p=head;p;p=p->next)
    {
        printf("%d\n",p->value);
    }
    
}
```

![image-20221203122317140](C:/Users/86198/Desktop/一.基础知识.assets/image-20221203122317140.png)

### 12.1可变数组

### 12.2链表

#### 12.2.1基础概念

- 链表都有一个头指针，一般以head来表示，存放的是一个地址
- 首结点：存放第一个有效数据的结点
- 头结点：在单链表的第一个结点之前，设有一个结点，它没有前驱，称之为头结点。头结点的数据域可以不存储任何信息，指针域指向第一个结点（首结点）的地址。
- 头指针：指向头结点的指针
- 尾结点：存放最后一个有效数据的结点
- 尾指针：指向尾结点的指针
- 链表就如同车链子一样，head指向第一个元素(头结点)：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。

![img](C:/Users/86198/Desktop/一.基础知识.assets/91a970fcc2278f2938921691abea808b.png)

![img](C:/Users/86198/Desktop/一.基础知识.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFyYW5vaWTimIY=,size_20,color_FFFFFF,t_70,g_se,x_16.png)



#### 12.2.2定义一个结构体

```c
tpyedef struct point{
    int value;           //数据域
    struct point *next;//定义指针域
}Node;
```

> **此时Node表示的就是 struct point 结构体,结构体中包含一个value值，和一个指针==（指向下一个结点）==**

#### 12.2.3创建一个链表

1. 头指针head的data随机
2. head->next 是首个有效数据结点（）
3. head->value 是随机数

```c
Node *create(int n)//n为链表结点个数
{
    Node *head, *node, *end; //定义头结点，普通结点，尾结点（均为结构指针）
    head = (Node *)malloc(sizeof(Node));//分配地址
    end = head;//若为空链表，则头尾结点都一样
    for(int i=0;i<n;i++)
    {
        node = (Node *)malloc(sizeof(Node));
        scanf("%d",&(node->value));
        node->next = NULL;
        end->next = node;
        end = node;
    }
    end->next = NULL; //这句话可以没有
    return head; 
}
```

2. 头指针head就是首个有效数据结点

```c
#include <stdio.h>
#include <stdlib.h>
struct node {
	int value;
	struct node *next;
};
int main() {
	struct node *head,*p,*q;  //p是临时指针，q指向最后一个结点
	int i,x;
	head=NULL;
	while(1) {
		scanf("%d",&x);
		if(x==-1) {
			break;
		} 
        else {
            p=(struct node *)malloc(sizeof(struct node));  //构建一个结点
			p->value=x;
			p->next=NULL;
			if(head==NULL){
				head = p;      //此时最后一个指针也就是head，head存放第一个有效数据
			}
			else{
				q->next=p;     //
			}
			q=p;               //q指向p
		}
	}
	for(p=head;p;p=p->next)
	{
		printf("%d\n",p->value);
	}
}
```

3. 逆序链表的创建

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct point
{
    int value;
    struct point *next;
}Node;
void print(Node *head)
{
    for(Node*p = head; p ; p = p->next)
    {
        printf("%d ",p->value);
    }
    printf("\n");
}
int main()
{
    Node *head = NULL;
    while(1)
    {
        int x;
        scanf("%d",&x);
        if(x==-1)break;
        //create a node
        Node *p = (Node*)malloc(sizeof(Node));
        p->value = x;
        p->next = NULL;
        // insert at head
        p->next = head;     //逆序的关键在于头插，在head之前插入一个结点，再将head前移
        head = p;
        //head = insert_node(head,p);
    }
    print(head);
}
```





#### 12.2.4 修改链表节点值

```c
void change(Node *list,int n)//n为要修改的结点
{
    Node *t = list;     //结构指针赋值
    int i=0;
    for(i = 0;i < n&& t!=NULL;i++)
    {
        t = t->next;
    }
    if(t!=NULL)
    {
        scanf("%d",&(t->value));
    }
    else
    {
        printf("not exist");
    }
}
```

#### 12.2.5删除链表结点

![img](C:/Users/86198/Desktop/一.基础知识.assets/70.png)

删除链表的元素也就是把前节点的指针域越过要删除的节点指向下下个节点。即：p->next = q->next;然后放出q节点的空间，即free(q);

```c
void delete(Node *list,int n)
{
    Node *p = list;
    Node *q;
    int i = 0;
    while(i < n && p != NULL) //一是判断是否为空链表，二是判断给的n是否大于链表的结点数    
    {
        q = p;
        p = p->next;
        i++;
    }
    if(t!=NULL)   
    {
        q->next = p->next;
        free(p);
    }
    else
    {
        printf("not exist");
    }
}
//按照结点的值进行寻找
for(Node *p = head,*q=NULL; p ; q = p, p = p->next)
{
    if(p->value==x)
    {
        if(q!=NULL) 
        {
            q->next=p->next;
        }
        else    //考虑第一个结点的特殊情况
        {
            head = p->next;
        }
        free(p);
    }
}
```

#### 12.2.6插入链表结点

![img](C:/Users/86198/Desktop/一.基础知识.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY5MzA3MQ==,size_16,color_FFFFFF,t_70.png)

![img](C:/Users/86198/Desktop/一.基础知识.assets/70-16700592281415.png)

插入结点就是用插入前节结点的指针域链接上插入节结点的数据域，再把插入结点的指针域链接上插入后结点的数据域。根据图，插入结点也就是：e->next = head->next; head->next = e;

增加链表节点用到了两个结构体指针和一个int数据。

> **将第一个结点编号为0情况，插入结点在编号结点之后**

```c
void insert(Node *list,int n)   
{
    Node *p=list;
    Node *q;
    int i = 0;
    if(p == NULL && n == 0) //特判
    {
        q = (Node*)malloc(sizeof(Node));
        scanf("%d",&(q->value));
        p = q;
    }
    while(i < n  && p != NULL)
    {
        p = p->next;
        i++;
    }
    if(p != NULL)
    {
        q = (Node*)malloc(sizeof(Node));
        scanf("%d",&(q->value));
        q->next=p->next;
        p->next = q;
    }
    else
    {
        printf("not exist");
    }
}
```

边界条件,头插入法**==(head 不含有效数据，插入结点在头结点之后)==**

```c
Node *head = (Node*)malloc(sizeof(Node));
head->next = NULL;
Node *p = (Node *)malloc(sizeof(Node));
p->value = x;
p->next = head->next;
head->next = p;
```

插入结点在==第idx个结点==之前情况  head结点是第一个结点（）

```c
void insert_at(List*plist,int idx,int x)
{
    Node *n = create(x);
    Node *p = NULL;
    if(idx> 0)   //考虑idx为0情况，
    {
        for(p=plist->head;p;p=p->next)
        {
            if(idx == 1)break;
            idx--;
        }
    }
    if(p!=NULL)  //p是要插入的结点的前一个结点
    {
        n->next = p->next;
        p->next = n;        //顺序u
    }
    if(p == plist->head)  //考虑特殊情况，边界条件下，n变为head
    {
        n->next = plist->head;
        plist->head = n;
    }
}
```





#### 12.2.7输出链表

```c
int len = 0;
for(Node *p = head;p;p = p->next)
{
    printf("%d",p->value);
    len++;  //计算链表的长度
}


while(t != NULL)  
{
    printf("%d ",t->value);
    t=t->next;
}
```



#### 12.2.8 链表的搜索

#### 12.2.9链表的清空

```c
void list_remove_all(List *list)
{
	for(Node *p = list->head;p;)
	{
	    Node *q = p->next; //先保留当前结点的下一个结点，防止free后无法衔接
	    free(p);
	    p = q;
	}
	list->head = NULL;//这句话不可缺少，使得printf输出时，直接因为head==NULL，跳出循环
}
```

#### 12.2.10 链表的合并

```c
typedef struct point
{
    int value;
    struct point *next;
}Node;


List merge(List L1,List L2)
{
    Node *head = (Node* )malloc(sizeof(Node));
    Node *p = head;
    Node *p1 = L1;
    Node *p2 = L2;
    while(p1 != NULL && p2 != NULL)
    {
        if(p1 -> value < p2 -> value)
        {
            p -> next = p1;
            p1 = p1 -> next;
            p = p - next ;
        }
        else
        {
            p -> next = p2;
            p2 = p2 -> next;
            p = p - next ;
        }
    }
    for(;p1;p1 = p1 -> next)
    {
        p -> next = p1;
        p  = p -> next;
    }
    for(;p2;p2 = p2 -> next)
    {
        p -> next = p2;
        p = p -> next;
    }
    p -> next = NULL;
    return head;
}
```

#### ==12.2.11 链表的逆转==

将给定单向链表逆置，即表头置为表尾，表尾置为表头

方法一： 带头指针法的头插法

```c
struct Node* reserve(struct Node *head)
{
    struct Node *t,*q,*p;
    t = (struct Node*)malloc(sizeof(struct Node));
    t->next = NULL;
    for(p = head;p;p = p -> next)
    {
        q = (struct Node*)malloc(sizeof(struct Node));
        q -> value = p -> value;
        q -> next = t -> next; // 此处相当于在头指针后进行插入
        t -> next = q;
    }
    return t->next; //此时t是一个头指针
}
```

单链表的**分段**逆转(带头结点)，直接在原链表上逆转，没有新建

```c
void reserve(struct Node* L,int k)
{
    struct Node *p = (struct Node*)malloc(sizeof(struct Node));
    int cnt = 0;
    for( p = L->next;p;p = p -> next)
    {
        cnt++;  //计算链表的长度
    }
    if(k == 1 || k > cnt)
    {
        return ;
    }
    struct Node *t,new,old,temp;
    p = L;
    for(int i = 0 ;i < cnt / k;i++)  //记录逆转的轮数
    {
        new = p -> next;
        old = new -> next;
        t = new;
        for(int cnt1 = 1;cnt1 < k;cnt1++)  //逆转的次数等于k-1
        {
            temp = old -> next;
            old -> next = new;
            new = old;
            old = temp;
        }
        p -> next = new;
        t -> next = old;
        p = t;
    }
}
```

单链表的逆转（原链表操作，整体,带头结点）

```c
void reserve(Node*head)
{
    Node *p = (Node*)malloc(sizeof(Node));
    int cnt = 0;
    for( p = head->next;p;p = p -> next)
    {
        cnt++;  //计算链表的长度
    }
    Node *t,*new,*old,*temp;
    p = head;
    new = p -> next;     //表示第一个结点
    old = new -> next;   
    t = new;             //记录第一个有效数据结点的位置，要使它的next最后变为NULL
    for(int cnt1 = 1;cnt1 < cnt;cnt1++)  //逆转的次数等于总长度cnt-1
    {
        temp = old -> next;       //先记录为逆转的下一个结点，后续使old变为old->next
        old -> next = new;        //开始逆转
        new = old;                //更替，已经逆转到old结点
        old = temp;
    }
    p -> next = new;              //p是head，head的next是最后一个结点
    t -> next = old;              //old变为NULL，t是第一个有效数据的结点，逆转后是最后一个，next变为NULL
}
```















#### ==12.2.10总结(单头单向无哨兵)==

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct point
{
    int value;
    struct point *next;
}Node;
Node*create(int x )
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->value = x;
    p->next = NULL;
    return p;
}
Node*insert_head(Node *head,Node*p)
{
    p->next = head;
    head = p;
    return head;
}
void print(Node *head)
{
    for(Node*p = head; p ; p = p->next)
    {
        printf("%d ",p->value);
    }
    printf("\n");
}
int main()
{
    Node *head,*p,*q;
    head = NULL;
    while(1)
    {
        int x;
        scanf("%d",&x);
        if(x==-1)break;
        //create a node
        p=create(x);
        // insert at end
        //if(head == NULL)  head = p;
        //else q->next = p;
		//q=p;  正向排序，接在末尾
        head = insert_head(head,p);
    }
    print(head);
}
```

全局结构

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct point
{
    int value;
    struct point *next;
}Node;

typedef struct list
{
    Node *head;
}List;          //list代表整个链表

Node*create(int x )
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->value = x;
    p->next = NULL;
    return p;
}
void*insert_head(List *plist,Node*p)
{
    p->next = plist->head;
    plist->head = p;         //在另一结构中返回改变后的head
}
int list_search(List *plist,int x)
{
    int ret = -1;
    int loc = 00;
    for(Node*p =plist->head;p;p=p->next)
    {
        if(p->value == x)
        {
            ret = loc;
            break;
        }
        loc++;
    }
    return ret;
}
int list_length(List *plist)
{
    int ret=0;
    for(Node *p = plist->head;p;p = p->next)
    {
        ret++;
    }
    return ret;
}
void insert_at(List*plist,int idx,int x)
{
    Node *n = create(x);
    Node *p = NULL;
    if(idx> 0)   //考虑idx为0情况，
    {
        for(p=plist->head;p;p=p->next)
        {
            if(idx == 1)break;
            idx--;
        }
    }
    if(p!=NULL)
    {
        n->next = p->next;
        p->next = n;
    }
    if(p == plist->head)  //考虑特殊情况，边界条件下，n变为head
    {
        n->next = plist->head;
        plist->head = n;
    }
}
void list_delete1(List *plist,int x)
{
    for(Node*p = plist->head,*q = NULL;p;q = p, p=p->next)
    {
        if(p->value ==x)
        {
            if(q!=NULL)
            {
                q->next = p->next;
                free(p);
                break;
            }
            else
            {
                plist->head = p->next;
                break;
            }
        }
    }
}
void list_delete2(List *plist,int x)
{
    Node *p = plist->head;
    Node *q = NULL;
    while(1)
    {
        if(p->value ==x)
        {
            if(q!=NULL)
            {
                q->next = p->next;
                free(p);
                break;
            }
            else
            {
                plist->head = p->next;
                break;
            }
    	}
    	q = p;
        p = p->next;
    }
}
void list_delete3(List *plist,int x)//删除所有的x
{
    for(Node*p = plist->head,*q = NULL;p;)
    {
        if(p->value ==x)
        {
            Node *r = p->next;
            if(q!=NULL)
            {
                q->next = p->next;
            }
            else
            {
                plist->head = p->next;
            }
            free(p);
            p=r;
        }
        else
        {
            q = p;
            p = p->next;
        }
    }
}//问题核心在于，删除之后q不变
void list_append(List *plist,int x) //在最后的结点插入
{
    Node *n = create(x);
    Node *p;
    for(*p=plist->head;p&&p->next;p=p->next);//p->next不能为NULL
    if(p==NULL)  //考虑p为NULL情况，此时p不进入for
    {
        plist->head = n;
    }
    else
    {
        p->next = n;
    }
}
void list_earse_all(List *plist)
{
    for(Node *p = plist->head;p;)
    {
        Node*q = p->next;
        free(p);
        p = q;
    }
}
void list_remove_all(Node *p) //递归版
{
    if(p == NULL)
    {
        return ;
    }
    list_remove_all(p->next);
    free(p);
}
void print(List *plist)
{
    for(Node*p = plist->head; p ; p = p->next)
    {
        printf("%d ",p->value);
    }
    printf("\n");
}
int main()
{
    List list = {NULL};
    Node *head,*p,*q;
    head = NULL;
    while(1)
    {
        int x;
        scanf("%d",&x);
        if(x==-1)break;
        //create a node结点的创建
        p=create(x);
        //结点的正向插入，在末尾来连接
        // insert at end
        //if(head == NULL)  head = p;
        //else q->next = p;
		//q=p;  正向排序，接在末尾
        insert_head(&list,p);
    }
    
    //链表在特定位置！！！前！！！插入
    //insert_at(&list,0,9);
    
    //链表的删除（特定位置）
    //list_delete1(&list,1);
    //list_delete2(&list,3);
    
    //链表的插入末位
    //list_append(&list,100);
    print(&list);
    
    //链表的搜索
    //scanf("%d",&x);
    //int loc = list_search(&list,x);
    //printf("%d\n",loc); 
    
}

```

### 12.3双头单向链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct _node 
{
	int value;
	struct _node *next;
}Node;

typedef struct {
    Node *head;
    Node *tail;
} List;

List list = {NULL
};


List list_create()
{
	List list = {NULL
	};
	return list;
}

Node* create_node(int x)
{
	Node *n = (Node*)malloc(sizeof(Node));
	n->value = x;
	n->next = NULL;
	return n;
}

void insert_head(List *plist, int x)  //插入在head之前
{
	Node *p = create_node(x);
	if(plist->head != NULL)
	{
		p->next = plist->head;
		plist->head = p;
	}
	else
	{
		plist->head = plist->tail = p;
	}
}

int list_search(List *plist,int x)
{
	int ret = -1;
	int loc = 1;
	for(Node *p = plist->head;p;p = p->next)
	{
		if(p->value == x)
		{
			ret = loc;
			break;
		}
		loc++;
	}
	return ret;
}

int list_length(List *plist)
{
    int ret=0;
    for(Node *p = plist->head;p;p = p->next)
    {
        ret++;
    }
    return ret;
}


void list_append(List *plist, int x)
{
	Node *p = create_node(x);
	if(plist->tail == NULL)
	{
		plist->head = plist->tail = p;
	}
	else
	{
		plist->tail->next = p;
		plist->tail = p;
	}
}


int list_get(List *plist, int index)
{
	int cnt = 0;
	for(Node*p=plist->head;p;p=p->next)
	{
		if(index == cnt)
		{
			return p->value;
		}
		cnt++;
	}
}
void list_insert_at(List *plist,int idx,int x)  //插入在第idx个结点之前
{
	Node *n = create_node(x);
    Node *q = NULL;
    Node *p;
    for(p = plist->head;p;q=p,p=p->next)
    {
    	if(idx == 1)
    	{
    		break;
		}
		idx--;
	}
	if(plist->head)
	{
		if(q)
		{
			q->next = n;
			n->next = p;
		}
		else
		{
			n->next = plist->head;
			plist->head = n;
		}
	}
	else
	{
		if(idx > 1)
		{
			printf("not exist");
		}
		else
		{
			plist->head = plist->tail = n;
		}
	}
}
void list_delete(List *plist, int x)
{
	for(Node *p = plist->head,*q = NULL;p;)
	{
		if(p->value == x)
		{
			Node*r = p->next;
			if(q==NULL)
			{
				plist->head = p->next;
			}
			else
			{
				q->next = p->next;
			}
			free(p);
			p = r;
		}
		else
		{
			q=p;
			p=p->next;
		}
	}
}
void list_free(List *plist)
{
	for(Node *p = plist->head;p;)
	{
		Node *q = p->next;
		free(p);
		p = q;
	}
	plist->head = plist->tail = NULL;
}

void print(List*plist)
{
	for(Node*p = plist->head;p;p = p->next)
	{
		printf("%d ",p->value);
	}
}
int main()
{
	Node *p,*q;
	while(1)
	{
		int x;
		scanf("%d",&x);
		if(x==-1)
		{
			break;
		}
		else
		{
			p = create_node(x);
			if(list.head == NULL)
			{
				list.head = list.tail = p;
			}
			else
			{
				q->next = p;
			}
			q = p;
		}
	}
	list.tail = p;
	//insert_head(&list,6);
	//printf("%d\n",list_search(&list,2));
	list_insert_at(&list,1,-1);
	//list_delete(&list,1);
	//list_append(&list,3);
	//list_free(&list);
	print(&list);
}
```







### 12.4双头双向链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct point
{
	int value;
	struct point *next;
	struct point *prev;
}Node;

typedef struct list
{
	Node *head;
	Node *tail;
}List;

List list = {NULL};     //初始化定义一个链表

Node* create_node(int x)
{
	Node *n = (Node*)malloc(sizeof(Node));
	n->value = x;
	n->next = NULL;    
	n->prev = NULL;    //bie'wan
	return n;
}
void insert_head(List*plist,int x)
{
	Node*p = create_node(x);
	if(plist->head != NULL)
	{
		p->next = plist->head;
		plist->head->prev = p;
		plist->head = p;
	}
	else
	{
		plist->head = plist->tail = p;
	}
	
}

int list_search(List *plist,int x)
{
	int ret = -1;
	int loc = 1;
	for(Node *p = plist->head;p;p = p->next)
	{
		if(p->value == x)
		{
			ret = loc;
			break;
		}
		loc++;
	}
	return ret;
}

int list_length(List *plist)
{
    int ret=0;
    for(Node *p = plist->head;p;p = p->next)
    {
        ret++;
    }
    return ret;
}

void insert_at(List*plist,int idx,int x) //插入在第idx个结点之前
{
    Node *n = create_node(x);
    Node *p = NULL;
    if(plist->head)
    {
        for(p=plist->head;idx != 1;p=p->next,idx--);
        if(p == plist->head)
        {
            n->next = p;
            p->prev = n;
            plist->head = n;
        }
        n->prev = p->prev;
        p->prev->next = n;
        n->next = p;
        p->prev = n;
    }
    else
    {
    	if(idx > 1)
    	{
    		printf("not exist");
		}
		else
		{
			plist->head = plist->tail = n;
		}
    }
}
void list_delete1(List*plist,int x)
{
	Node *p;
	int flag = 0;
	for(p = plist->head;p;)
	{
		if(p->value == x)
		{
			flag = 1;
			Node *n = p->next;
			if(p->prev)
            {
                p->prev->next = p->next;
            }
            else
            {
                plist->head = p->next; 
            }
            if(p->next)
            {
                p->next->prev = p->prev;
            }
            else
            {
                plist->tail = p->prev;
            }
			free(p);
			p = n;
		}
		else
		{
			p = p -> next;
		}
	}
	if(flag == 0)
	{
		printf("not exist\n");
	}
}
void list_delete2(List *plist,int x)
{
    Node *p = plist->head;
    int flag = 0;
    while(p)
    {
        if(p->value ==x)
        {
        	flag = 1;
            Node *n = p->next;
            if(p->prev)
            {
                p->prev->next = p->next;
            }
            else
            {
                plist->head = p->next; 
            }
            if(p->next)
            {
                p->next->prev = p->prev;
            }
            else
            {
                plist->tail = p->prev;
            }
            free(p);
            p = n;
    	}
    	else
    	{
    		p = p->next;
		}
    }
    if(flag == 0)
	{
		printf("not exist\n");
	}
}
void list_append(List *plist,int x)
{
	Node *n = create_node (x);
	if(plist->tail)
	{
		plist->tail->next = n;
		n->prev = plist->tail;
		plist->tail = n;
	}
	else
	{
		plist->head = plist->tail = n;
	}
}
void list_earse_all(List *plist)
{
	for(Node*p = plist->head;p;)
	{
		Node *q = p->next;
		free(p);
		p = q;
	}
	plist->head = plist->tail = NULL;
}
void list_remove_all(Node*p)
{
	if(p == NULL)
	{
		return;
	}
	else
	{
		list_remove_all(p->next);
		free(p);
	}
    list.head = list.tail = NULL;
}
void print(List*plist)
{
	for(Node*p = plist->head;p;p = p->next)
	{
		printf("%d ",p->value);
	}
}
int main()
{
	Node *p,*q;
	while(1)
	{
		int x;
		scanf("%d",&x);
		if(x==-1)
		{
			break;
		}
		else
		{
			p = create_node(x);
			if(list.head == NULL)
			{
				list.head = list.tail = p;
			}
			else
			{
				q->next = p;
				p->prev = q;
			}
			q = p;
		}
	}
	list.tail = p;
	//insert_head(&list,6);
	//printf("%d\n",list_search(&list,2));
	//insert_at(&list,2,-1);
	//list_delete1(&list,1);
	//list_delete2(&list,2);
	//list_append(&list,3);
	//list_earse_all(&list);
	//list_remove_all(list.head);
	print(&list);
	
}

```

### 12.5 哨兵单向链表

使head始终非空

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct point{
	int value;
	struct point *next;
}Node;

typedef struct list{
	Node *head;
	//Node *tail;
}List;

Node *create_node(int x)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->value = x;
	p->next = NULL;
	return p;
}
List create_list()
{
	Node *p = create_node(0);
	List list;
	list.head = p;
	return list;
}

void insert_head(List *plist,int x)  //头结点不含有效数据，头结点的后一个数据含有效数据，故插入在头结点之后
{
	Node *p = create_node(x);
	p->next = plist->head->next;
	plist->head->next = p;
}

int list_search(List *plist,int x)
{
	int ret = -1;
	int loc = 0;
	for(Node *p = plist->head->next;p;p = p->next )
	{
		if(p->value == x)
		{
			ret = loc ;
			break;
		}
		loc++;
	}
	return ret;
}

int list_length(List *plist)
{
    int ret=0;
    for(Node *p = plist->head->next;p;p = p->next)
    {
        ret++;
    }
    return ret;
}

void insert_at(List *plist,int idx,int x) //插入在第idx个结点（不包含哨兵）之前
{
	Node *n = create_node(x);
	if(idx == 1)
	{
		n->next = plist->head->next;
		plist->head->next = n;
	}
	if(idx >1)
	{
		Node *p;
		for(p = plist->head->next;idx >2;p = p->next,idx--);
		n->next = p->next;
		p->next = n;
	}
}

void list_delete1(List *plist,int x)
{
	Node *p,*q,*n;
	for(p = plist->head->next,q = plist->head;p;)
	{
		if(p->value == x)
		{
			n = p->next;
			q->next = p->next;
			free(p);
			p = n;
		}
		else
		{
			q = p ;
			p = p->next;
		}
	}
}

void list_delete2(List *plist,int x)
{
	Node *p = plist->head->next;
	Node *q = plist->head;
	while(p)
	{
		if(p->value == x)
		{
			Node *n = p->next;
			q->next = p->next;
			free(p);
			p = n;
		}
		else
		{
			q = p;
			p = p->next;
		}
	}
}

void list_append(List *plist ,int x)
{
	Node *n = create_node(x);
	Node *p;
	for(p= plist->head->next;p->next;p = p->next);
	p->next = n;
	
}

void list_earse_all(List *plist)
{
	for(Node *p = plist->head->next;p;)
	{
		Node *n = p->next;
		free(p);
		p = n;
	}
	plist->head->next = NULL;
}

void print(List *plist)
{
	for(Node *p = plist->head->next;p;p = p->next)
	{
		printf("%d ",p->value);
	}
}
int main()
{
	List list = create_list();
	Node *p;
	Node *q = list.head;
	while(1)
	{
		int x;
		scanf("%d",&x);
		if(x == -1)
		{
			break;
		}
		else
		{
			p = create_node(x);
			q->next = p;
			q = p;
		}
	}
	//insert_head(&list,-1);
	//insert_at(&list,2,-1);
	//list_delete1(&list ,1);
	//list_delete2(&list ,2);
	//list_append(&list,-1);
	//list_earse_all(&list);
	print(&list);
}
```

### 12.3 环形链表

#### 12.3.1 环形链表的输出

```c
void print(struct Node *r)
{
    if(r == NULL)
    {
        return ;
    }
    else
    {
        struct Node *p = r->next;
        printf("%d",p->value);
        p = p -> next;
        while( p != r -> next)
        {
            printf(" %d",p->value);
            p = p ->next;
        }
    }
}
```





# 十三.程序结构

### 13.1全局变量与静态本地变量

（一）全局变量

1. 全局变量

- 定义在函数之外的变量
- **全局变量具有全局的生存期和作用域**
  - 与任何函数都无关
  - 在任何函数内部都可以使用

2. 全局变量的初始化

- > **没有初始化的全局变量会得到0值**

- 指针得到NULL值

- 只能用编译时刻已知的值来初始化全局变量

  - eg：int a = f();❌
  - b = 10; int a=b;❌

- 它的初始化要在main函数之前

  - 即：int a  = 10;  
  - ​        int a  =  20; ❌

- **且全局变量只能赋一次初值**

3. 全局变量的隐藏

- > **如果函数内部存在与全局变量同名的变量，则全局变量被隐藏**



> **错题集：**
>
> 1. **凡是函数中未指定存储类别的局部变量，其隐含的存储类型为( 自动auto)。**
>
> 解释：
>
> 函数中的局部变量，如果不**专门声明为static存储类别**，都是动态的分配存储空间的，**数据储存在动态存储区中。这类变量叫做自动变量**，自动变量可以用关键字auto作为存储类别的声明，实际上关键字auto是可以省略的（一般都是不写的），不写则自动隐含为“自动存储类别”。
>
> 2. C语言全局变量的初始化是在哪个阶段完成的
>
>    answer：**mian函数开始之前**
>
>    解释：无💢

（二）静态本地变量

1. 静态本地变量概况

- 在本地变量定义时加上static修饰符就成为静态本地变量

- > **当函数离开的时候，静态本地变量会继续存在并保持其值**

- 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开的值

- **静态局部变量如何没有赋值，其存储单元中将是0**（实质是全局变量）

2. 静态本地变量的实质：

- 实质是：特殊的全局变量

  - 它们位于相同的内存区域

  - > **静态本地变量具有全局的生存期，函数内的局部作用域**

  - static在这里的意思是局部作用域（本地可访问）




![image-20221230135819763](重难点手册.assets/image-20221230135819763.png)

全局变量和静态变量在内存中存放在同一位置，即**静态区/全局区，不是动态存储区**

### 13.2编译预处理和宏

 #开头的是编译预处理指令，==它不是c语言的成分==



```c
#include <stdio.h>

//const double PI = 3.14159;  两者等价
#define PI 3.14159

int main()
{
    printf("%f\n",2*PI*3);
}
```

#define 表示宏

- #define <name><value>

- > **宏定义时不存在类型问题，宏名无类型，它的参数也无类型**

- > **注意没有结尾的分号，因为不是C的语句**

- 名字必须是一个单词（符合c标识符的要求，通常全大写），值可以是任何东西

  - 例如：代码，"%f\n"

  - ```c
    #define PRT for(int i =0 ;i<10;i++){\
         printf("%d",a[i]);\
    }
    #define format "%f\n"
    printf(format,2*PI*3.0);
    ```

  - 

- 宏中宏

  - ```c
    #define PI 3.1415
    #define PI2 2*PI
    ```

  预定义的宏

  ```c
  printf("%d\n",__LINE__);//行数
  printf("%s\n",__FILE__);//文件名
  printf("%s\n",__DATE__);//日期
  printf("%s\n",__TIME__);//时间
  5
  C:\Users\86198\Desktop\删除\宏.c
  Dec 16 2022
  10:37:25
  ```

- 像函数的宏(可以带参数)

  - ```c
    #define cube(x) ((x)*(x)*(x))
    ……；
        printf("%d",cube(3));  //27
    ```

  - 带多个参数

  - ```c
    #define MIN(a,b) ((a)>(b)?(b):(a))
    ```

    

  - 错误定义的宏

  - ```c
    #define f(x) (x*100)  //特殊情况，f（5+3）变为（5+3*100）
    #define f(x) (x)*100  //特殊情况  10/f（10)变为 10/10*100
    ```

    > **带参数的宏的原则：一切都要括号，整个值也要括号，参数出现的每一个地方都要括号**

==#运算符==表示使变量（n）以字符串形式表示

```c
#define print(n) printf(#n "=%d\n",(n))


int max = 10;
print(max);    //等价于printf("max""=%d\n",(max));
```

==##运算符==表示连接

```c
#define mycase(item,id)\
case id:\
    item##_##id = id;\
break;

switch(max){
        mycase(x,0);
}
等价于
    switch(max){
        case 0:x_0 = 0;break;
    }
```



### 13.3大程序结构

- 一个.c文件是一个编译单元
- 编译器每次只处理一个编译单元



```c
main.c
#include<stdio.h>
#include"max.h"

int main()
{
    int a,b;
    scanf("%d %d",&a,&b);
    printf("%d",max(a,b));
}
max.c
#include"max.h"
    
int max(int a,int b)
{
    if(a>b)return a;
    else return b;
}

max.h
int max(int a,int b);
```



#### 13.3.1 头文件

- 把函数原型放到一个头文件（.h结尾）中，在需要调用这个函数的源代码文件（.c结尾），中的#include这个头文件，就能让编译器在编译的时候==*知道函数的原型*==

- > 在⛔**使用和⛔定义函数**的地方都要有#include这个头文件
  >
  > 一般的做法是对**任何.c都有对应的同名的.h（main除外）**,把所有**对外公开的函数的原型和全部变量的声明**放进去

- 至于不对外公开的函数

  - 在**函数**前面加上==static==就使他成为只在所在的编译单元才能使用的函数
  - 在**全局变量**前面加上==static==就使他成为只能在所在的编译单元中被使用的全局变量

##### 1.#include

- #include是一个编译预处理指令和宏一样，在编译之前就处理了

- **它是将头文件的全部文本内容原封不动地插入到它所在的地方**

- #include有两种形式指出要插入的文件
  - “ ”要求编译器首先在当前目录（.c文件所在的目录）寻找这个头文件，如果没有，再到编译器指定的目录寻找
  - <>让编译器只在指定的目录寻找

##### 2.**#include的误区**

-  #include不是用来引入库的（作用就是文本的替换）
-  stdio.h里只有printf的原型，printf的代码在另外的地方，从而==#include<stdio.h>的作用就是让编译器知道printf函数的原型，保证你**调用时给出的参数类型**正确==

#### 13.3.2声明

1. ###### ==变量==的定义和声明的辨析

- int i;              是变量的定义
- ==extern int i==;  是变量的声明

```c
main.c
#include<stdio.h>
#include"max.h"

int main()
{
    int a,b;
    scanf("%d %d",&a,&b);           //5 6
    printf("%d",max(a,b) + all);    //9
}
max.c
#include"max.h"
int all = 3;     //定义一个全局变量
int max(int a,int b)
{
    if(a > b)return a;
    else return b;
}

max.h
int max(int a,int b);
extern int all;  //声明一个变量
```





2. 声明和定义

- 声明是不产生代码的东西，**只有声明才能放在头文件中（否则会造成一个项目中多个编译单元里有重名的实体redefinition）**
  - 函数原型   int max(int a,int b);
  - 变量声明   extern int i;
  - 结构声明   struct
  - 宏声明       #define ·····
  - 类型声明   typedef ·····
- 定义是产生代码的东西

```c
main.c
#include<stdio.h>
#include"max.h"

int main()
{
    int a,b;
    scanf("%d %d",&a,&b);           //5 6
    printf("%d",max(a,b) + all);    //9
}
max.c
#include"max.h"
int all = 3;     //定义一个全局变量
int max(int a,int b)
{
    if(a > b)return a;
    else return b;
}

max.h
int max(int a,int b);
extern int all;  //声明一个变量
```

错误❌展示（不能包含body）

```c
main.c
#include<stdio.h>
#include"max.h"   //用一下文本内容代替
int max(int a,int b);
extern int all;  //声明一个变量
struct Node {
    int value;
    char *name;
}
#include"min.h"   //用一下文本内容代替
#include "max.h"
int max(int a,int b);
extern int all;  //声明一个变量
struct Node {
    int value;
    char *name;
}                //如此造成struct Node的redefinition❌
int main()
{
    int a,b;
    scanf("%d %d",&a,&b);           //5 6
    printf("%d",max(a,b) + all);    //9
}

max.c
#include"max.h"
int all = 3;     //定义一个全局变量
int max(int a,int b)
{
    if(a > b)return a;
    else return b;
}

max.h
int max(int a,int b);
extern int all;  //声明一个变量
struct Node {
    int value;
    char *name;
}

min.h
#include "max.h"
```

错误更改√

```c
main.c
#include<stdio.h>
#include"max.h"

int main()
{
    int a,b;
    scanf("%d %d",&a,&b);           //5 6
    printf("%d",max(a,b) + all);    //9
}
max.c
#include"max.h"
int all = 3;     //定义一个全局变量
int max(int a,int b)
{
    if(a > b)return a;
    else return b;
}

max.h
    
#ifndef _MAX_H
#define _MAX_H
int max(int a,int b);
extern int all;  //声明一个变量
struct Node {
    int value;
    char *name;
}
#endif
```

3. 标准头文件结构

> **#ifndef _MAX_H**
>
> **#define _MAX_H**
>
> **……**
>
> **#endif**
>
> **#ifndef表示如果_MAX_H没有被定义，则执行define一下语句**
>
> 
>
> **如果已经被定义，则直接跳到#endif**
>
> ⛔♥**运用条件编译和宏，保证这个头文件在一个编译单元中只能被#include一次，从而防止重复定义造成错误**
>
> **#pragma once 也能起到相同的作用**

```c
#include <stdio.h>
#define debug

int main()
{
    printf("hello");
#ifdef debug        
    printf("byebye");
#else
    printf("world");
#endif
}
```

> 💕⛔#if**def** debug  ·····  表示如果debug被**定义**了，就执行后面语句**
>
> **#else  ······             表示如果没有被定义，则执行else后面语句**
>
> **#endif**

![img](C:/Users/86198/Desktop/一.基础知识.assets/4982f69711dac4c20aa2ad8c5d79af24-16712023134055.gif)

> **这边特别注意一下，由于是define与否，所以用#ifdef**
>
> **普通版的话，就是#if 1 或者#if 0     #endif**

实战举例：

头文件放声明

![image-20221222184730243](C:/Users/86198/Desktop/一.基础知识.assets/image-20221222184730243.png)

.c文件放定义

![image-20221222184803040](C:/Users/86198/Desktop/一.基础知识.assets/image-20221222184803040.png)

![image-20221225205225823](重难点手册.assets/image-20221225205225823.png)

这个编译单元中，要用 k 这个变量，**但语法只是声明**。表示 k 变量不在这个编译单元中，而是在其他编译单元里。但实际上，你**又没有其他编译单元**。所以，编译的时候没问题，链接的时候没人认领 k，就错了





### 13.4 文件操作

- FILE *fopen(const char *restrict path,const char * restrict mode);

  - ```c
    int main()
    {
        FILE *fp = fopen("in(文件名)","r");
        if(fp)
        {
            int i;
            fscanf(fp,"&d",&i);
            printf("%d\n",i);
        }
        else
        {
            printf("can't open file\n");
        }
    }
    
    //标准写法
    FILE* fp = fopen("file","r");
    if(fp)
    {
        fscanf(fp , ...);
        fclose(fp);
    }
    else
    {
        ....
    }
    ```

  - ![image-20221230150443229](重难点手册.assets/image-20221230150443229.png)

- int fclose(FILE *stream);

- fscanf(FILE*,...);

- fprintf(FILE*,...);

#### 二进制读写

- size_t fread(void *restrict ptr(**指针**),size_t size（**每个单元的大小**）, size_t nitems（**单元数**）,FILE *restrict stream);
- size_t fwrite(const void *restrict ptr,size_t size,size_t nitems,FILE *restrict stream);
- FILE指针是最后一个参数
- 返回的是成功读写的项目数

```c
char buf[80];
fwrite (buf,sizeof(char),len,fp);
```

> **二进制文件的读写一般是通过对一个结构变量的操作进行的；**
>
> **于是nitem就是用来说明这次读写几个结构变量**



- long ftell(告知文件的位置)(FILE *stream);
- int fseek(FILE *stream,long offset,int whence(搜索方式));
  - SEEK_SET:从头开始
  - SEEK_CUR:从当前位置开始
  - SEEK_END:从尾开始



























# 十四.并行计算

### 14.1 pthread

- 线程操纵函数

  - pthread_create() : 创建一个线程

  - pthread_exit()   : 终止当前的线程

  - pthread_join():    阻塞当前线程，直至另一个线程运行结束

    

- 编写线程函数
  - void* add(void *args) //用于在创建的线程中运行，==返回值和参数为规定类型void *==

- 创建线程
  - pthread_t t1; //声明线程句柄
  - pthread_create(&t1,NULL,add,(void*)&ST);
  - //参数1为线程句柄，参数2为线程函数返回值，参数3为线程函数指针，参数4为线程函数参数
- 等待线程结束
  - pthread_join(t1,NULL);//调用该函数后，当前线程会阻塞，目标线程结束后当前线程继续执行

实战：

```c
#include <stdio.h>
#include <pthread.h>
void *run(void *args)
{
    for(int i = 0;i < 10 ; i++)
    {
        printf("hello\n");
    }
}
int main()
{
    pthread_t t1;
    pthread_create(&t1,NULL,run,NULL);
    for(int i = 0;i < 10;i++)
    {
        printf("bye\n");
    }
    pthread_join(t1,NULL)
}
```

